--create or replace function public.do_stats(mf public.filters default public.new_filter())
--returns public.stats as
--$$
--    select
--        row_number() over () as id,
--        count(distinct f.path) as musics,
--        count(distinct f.album) as albums,
--        count(distinct f.artist) as artists,
--        count(distinct f.genre) as genres,
--        (select count(distinct k.keywords) from (select unnest(public.array_cat_agg(f.keywords)) as keywords) as k) as keywords,
--        coalesce(sum(f.duration),0) as duration,
--        coalesce(sum(f.size),0) as size
--    from public.do_filter(mf) f;
--$$ language sql stable;
--
--drop type if exists public.playlist cascade;
--create type public.playlist as
--(
--    name text,
--    content text
--);
--
--create or replace function public.generate_playlist(mf public.filters default public.new_filter())
--returns table(content text) as
--$$
--        select
--            case when mf.relative is false then
--				coalesce('#EXTM3U' || E'\n' || string_agg(f.path, E'\n'), '')
--            else
--				coalesce('#EXTM3U' || E'\n' || string_agg(substring(f.path from char_length(f.folder)+2), E'\n'), '')
--            end
--        from (select path, folder from public.do_filter(mf)) f;
--$$ language sql stable;
--
--create or replace function public.generate_bests_artist_keyword(mf public.filters default public.new_filter(min_rating := 0.8))
--returns setof playlist as
--$$
--    with recursive rmusics as (
--		select path, folder, artist, keywords
--		from public.do_filter(mf)
--	),
--    rkeywords as (
--		select path, folder, artist, unnest(keywords) as k
--		from rmusics
--		group by path, folder, artist, keywords
--		order by k
--	)
--    select
--        (artist || '/' || k.k) as name,
--        case when mf.relative is false then
--			coalesce('#EXTM3U' || E'\n' || string_agg(path, E'\n'), '')
--        else
--			coalesce('#EXTM3U' || E'\n' || string_agg(substring(path from char_length(folder)+2), E'\n'), '')
--        end
--    from rkeywords k
--    group by artist, k;
--$$ language sql stable;
--
--
--create or replace function public.generate_bests_artist(mf public.filters default public.new_filter(min_rating := 0.8))
--returns setof playlist as
--$$
--    with recursive rmusics as (
--		select path, folder, artist
--		from do_filter(mf)
--	)
--    select
--        (m.artist || '/bests') as name,
--        case when mf.relative is false then coalesce('#EXTM3U' || E'\n' || string_agg(path, E'\n'), '')
--        else coalesce('#EXTM3U' || E'\n' || string_agg(substring(path from char_length(folder)+2), E'\n'), '')
--        end
--    from rmusics m
--    group by m.artist;
--$$ language sql stable;
--
--create or replace function public.generate_bests_genre(mf public.filters default public.new_filter(min_rating := 0.8))
--returns setof playlist as
--$$
--    with recursive rmusics as (
--		select path, folder, genre
--		from public.do_filter(mf)
--	)
--    select
--        (m.genre) as name,
--        case when mf.relative is false then coalesce('#EXTM3U' || E'\n' || string_agg(path, E'\n'), '')
--        else coalesce('#EXTM3U' || E'\n' || string_agg(substring(path from char_length(folder)+2), E'\n'), '')
--        end
--    from rmusics m
--    group by m.genre;
--$$ language sql stable;
--
--create or replace function public.generate_bests_keyword(mf public.filters default public.new_filter(min_rating := 0.8))
--returns setof playlist as
--$$
--    with recursive rmusics as (
--		select path, folder, keywords
--		from do_filter(mf)
--	),
--    rkeywords as (
--		select path, folder, unnest(keywords) as k
--		from rmusics
--		group by path, folder, keywords
--		order by k
--	)
--    select
--        (k.k) as name,
--        case when mf.relative is false then coalesce('#EXTM3U' || E'\n' || string_agg(path, E'\n'), '')
--        else coalesce('#EXTM3U' || E'\n' || string_agg(substring(path from char_length(folder)+2), E'\n'), '')
--        end
--    from rkeywords k
--    group by k;
--$$ language sql stable;
--
--create or replace function public.generate_bests(mf public.filters default public.new_filter(min_rating := 0.8))
--returns setof playlist as
--$$
--    select * from public.generate_bests_artist(mf) union
--    select * from public.generate_bests_genre(mf) union
--    select * from public.generate_bests_artist_keyword(mf) union
--    select * from public.generate_bests_keyword(mf);
--$$ language sql stable;
--create or replace function musicbot_public.new_music
--(
--    title text default '',
--    album text default '',
--    genre text default '',
--    artist text default '',
--    folder text default '',
--    youtube text default '',
--    spotify text default '',
--    number integer default 0,
--    path text default '',
--    rating float default 0.0,
--    duration integer default 0,
--    size integer default 0,
--    keywords text[] default '{}'
--) returns musicbot_public.raw_music as
--$$
--begin
--    return (musicbot_public.current_musicbot_id(), title, album, genre, artist, folder, youtube, spotify, number, path, rating, duration, size, keywords, now(), now());
--end;
--$$ language plpgsql stable;
--grant execute on function musicbot_public.new_music to musicbot_user;
