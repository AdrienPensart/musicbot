# if os.path.islink(__file__):
#     myself = os.readlink(__file__)
# else:
#     myself = __file__
# bin_folder = os.path.dirname(myself)
# commands_folder = 'commands'
# plugin_folder = os.path.join(bin_folder, commands_folder)
@click.option('--sync', envvar='MB_SYNC', help='Call DB synchronously', is_flag=True)

#@cli.command()
#@helpers.coro
#@helpers.add_options(helpers.concurrency)
#@click.argument('folders', nargs=-1)
#@click.pass_context
#async def insert(ctx, concurrency, folders, **kwargs):
#    '''Fast insert of musics files in database'''
#    from lib.lib import find_files
#    from lib.mfilter import Filter, supported_formats
#    from lib.file import File
#    import asyncpg
#    files = [f for f in find_files(folders) if f[1].endswith(tuple(supported_formats))]
#    await ctx.obj.db.execute('DELETE FROM music')
#    await ctx.obj.db.execute('SET synchronous_commit TO OFF')
#    sql = '''insert into music as m (title, album, genre, artist, folder, youtube, number, path, rating, duration, size, keywords) values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)'''
#    with tqdm(total=len(files), file=sys.stdout, desc="Loading music", leave=True, position=0, disable=config.quiet) as bar:
#        connection = await ctx.obj.db.connect()
#        async def insert(semaphore, f):
#            async with semaphore:
#                m = File(f[1], f[0])
#                try:
#                    l = m.to_tuple()
#                    await connection.execute(sql, *l)
#                except asyncpg.exceptions.CheckViolationError as e:
#                    logger.warning("Violation: {}".format(e))
#                bar.update(1)
#        semaphore = asyncio.BoundedSemaphore(concurrency)
#        tasks = [asyncio.ensure_future(insert(semaphore, f)) for f in files]
#        await asyncio.gather(*tasks)
#
#
#@cli.command()
#@click.argument('folders', nargs=-1)
#@click.pass_context
#def insert2(ctx, folders, **kwargs):
#    '''Fast insert of musics files in database'''
#    from lib.lib import find_files
#    from lib.mfilter import Filter, supported_formats
#    from lib.file import File
#    import psycopg2
#    with psycopg2.connect(ctx.obj.db.connection_string) as conn:
#        with conn.cursor() as cur:
#            cur.execute('DELETE FROM music')
#            sql = '''insert into music as m (title, album, genre, artist, folder, youtube, number, path, rating, duration, size, keywords) values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'''
#            files = [f for f in find_files(folders) if f[1].endswith(tuple(supported_formats))]
#            with tqdm(total=len(files), file=sys.stdout, desc="Loading music", leave=True, position=0, disable=config.quiet) as bar:
#                for f in files:
#                    m = File(f[1], f[0])
#                    cur.execute(sql, m.to_tuple())
#                    bar.update(1)
#
#
#@cli.command()
#@click.argument('folders', nargs=-1)
#@click.pass_context
#def insert3(ctx, folders, **kwargs):
#    '''Fast insert of musics files in database'''
#    from lib.lib import find_files
#    from lib.mfilter import Filter, supported_formats
#    from lib.file import File
#    import psycopg2
#    from psycopg2.extras import execute_values
#    with psycopg2.connect(ctx.obj.db.connection_string) as conn:
#        with conn.cursor() as cur:
#            cur.execute('DELETE FROM music')
#            files = [f for f in find_files(folders) if f[1].endswith(tuple(supported_formats))]
#            data = []
#            for f in files:
#                m = File(f[1], f[0])
#                data.append(m.to_tuple())
#                m.close()
#            sql = '''insert into music as m (title, album, genre, artist, folder, youtube, number, path, rating, duration, size, keywords) values %s'''
#            execute_values(cur, sql, data)
#
#
#@cli.command()
#@click.argument('folders', nargs=-1)
#@click.pass_context
#def insert4(ctx, folders, **kwargs):
#    '''Fast insert of musics files in database'''
#    from lib.lib import find_files
#    from lib.mfilter import Filter, supported_formats
#    from lib.file import File
#    import psycopg2
#    from psycopg2.extras import execute_batch
#    with psycopg2.connect(ctx.obj.db.connection_string) as conn:
#        with conn.cursor() as cur:
#            cur.execute('DELETE FROM music')
#            files = [f for f in find_files(folders) if f[1].endswith(tuple(supported_formats))]
#            data = []
#            for f in files:
#                m = File(f[1], f[0])
#                data.append(m.to_tuple())
#                m.close()
#            sql = '''select * from upsert_one (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'''
#            execute_batch(cur, sql, data)
#
#
#@cli.command()
#@click.argument('folders', nargs=-1)
#@click.pass_context
#def insert5(ctx, folders, **kwargs):
#    '''Fast insert of musics files in database'''
#    from lib.lib import find_files
#    from lib.mfilter import Filter, supported_formats
#    from lib.file import File
#    import psycopg2
#    from psycopg2.extras import execute_batch
#    with psycopg2.connect(ctx.obj.db.connection_string) as conn:
#        with conn.cursor() as cur:
#            files = [f for f in find_files(folders) if f[1].endswith(tuple(supported_formats))]
#            data = []
#            for f in files:
#                m = File(f[1], f[0])
#                data.append(m.to_tuple())
#                m.close()
#                #break
#            #sql = '''select * from upsert_one (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'''
#            #cur.execute("PREPARE myupsert AS select * from upsert_one ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)")
#            cur.execute("PREPARE myupsert AS select * from upsert(new_music($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12))")
#            sql = '''EXECUTE myupsert (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'''
#            execute_batch(cur, sql, data)
#            cur.execute("DEALLOCATE myupsert")
#
#
#@cli.command()
#@click.pass_context
#def test(ctx):
#    '''Fast insert of musics files in database'''
#    from lib.lib import find_files
#    from lib.mfilter import Filter, supported_formats
#    from lib.file import File
#    import psycopg2
#    from psycopg2.extras import execute_batch
#    with psycopg2.connect(ctx.obj.db.connection_string) as conn:
#        with conn.cursor() as cur:
#            sql = '''
#    select
#        id,
#        title,
#        album,
#        genre,
#        artist,
#        folder,
#        youtube,
#        number,
#        path,
#        rating,
#        duration,
#        size,
#        keywords
#    from music mv
#    where
#        (array_length(%(artists)s::text[], 1) is null or mv.artist = any(%(artists)s::text[])) and
#        (array_length(%(no_artists)s::text[], 1) is null or not (mv.artist = any(%(no_artists)s::text[]))) and
#        (array_length(%(albums)s::text[], 1) is null or mv.album = any(%(albums)s::text[])) and
#        (array_length(%(no_albums)s::text[], 1) is null or not (mv.album = any(%(no_albums)s::text[]))) and
#        (array_length(%(titles)s::text[], 1) is null or mv.title = any(%(titles)s::text[])) and
#        (array_length(%(no_titles)s::text[], 1) is null or not (mv.title = any(%(no_titles)s::text[]))) and
#        (array_length(%(genres)s::text[], 1) is null or mv.genre = any(%(genres)s::text[])) and
#        (array_length(%(no_genres)s::text[], 1) is null or not (mv.genre = any(%(no_genres)s::text[]))) and
#        (array_length(%(keywords)s::text[], 1) is null or %(keywords)s::text[] <@ mv.keywords) and
#        (array_length(%(no_keywords)s::text[], 1) is null or not (%(no_keywords)s::text[] && mv.keywords)) and
#        (array_length(%(formats)s::text[], 1) is null or mv.path similar to '%%.(' || array_to_string(%(formats)s::text[], '|') || ')') and
#        (array_length(%(no_formats)s::text[], 1) is null or mv.path not similar to '%%.(' || array_to_string(%(no_formats)s::text[], '|') || ')') and
#        mv.duration between %(min_duration)s and %(max_duration)s and
#        mv.size between %(min_size)s and %(max_size)s and
#        mv.rating between %(min_rating)s and %(max_rating)s and
#        (%(youtube)s is null or (%(youtube)s = mv.youtube))
#    order by
#        case when(%(shuffle)s = 'true') then random() end,
#        case when(%(shuffle)s = 'false') then artist end,
#        case when(%(shuffle)s = 'false') then album end,
#        case when(%(shuffle)s = 'false') then number end
#    limit %(limit)s
#'''
#            data = {'min_duration':0, 'max_duration':2147483647, 'min_size':0, 'max_size':2147483647, 'min_rating':0, 'max_rating':5, 'artists':[], 'no_artists':[], 'albums':[], 'no_albums':[], 'titles':[], 'no_titles':[], 'genres':[], 'no_genres':[], 'formats':[], 'no_formats':[], 'keywords':['best'], 'no_keywords':[], 'shuffle':True, 'relative':False, 'limit':2147483647, 'youtube': None}
#            cur.execute(sql, data)
#            print(cur.query.decode('utf-8'))


    if sync:
        sql = '''
delete from music_tags mt where mt.music_id = (select old.id from musics old where old.path = %(path)s limit 1);
with upsert_folder as (
    insert into folders as f (name, created_at)
    values (%(folder)s, now())
    on conflict (name) do update set
        updated_at=coalesce(EXCLUDED.updated_at, now()),
        name=EXCLUDED.name
    returning f.id as folder_id
),
upsert_artist as (
    insert into artists as a (name, created_at)
    values (%(artist)s, now())
    on conflict (name) do update set
        updated_at=coalesce(EXCLUDED.updated_at, now()),
        name=EXCLUDED.name
    returning a.id as artist_iD
),
upsert_album as (
    insert into albums as al (artist_id, name, created_at)
    values ((select artist_id from upsert_artist limit 1), %(album)s, now())
    on conflict (artist_id, name) do update set
        updated_at=coalesce(EXCLUDED.updated_at, now()),
        name=EXCLUDED.name
    returning al.id as album_id
),
upsert_genre as (
    insert into genres as g (name)
    values (%(genre)s)
    on conflict (name) do update set
        updated_at=coalesce(EXCLUDED.updated_at, now()),
        name=EXCLUDED.name
    returning g.id as genre_id
),
upsert_keywords as (
    insert into tags as t (name)
    select distinct k from unnest(%(keywords)s::text[]) k
    on conflict (name) do update set
        updated_at=coalesce(EXCLUDED.updated_at, now()),
        name=EXCLUDED.name
    returning t.id as tag_id
),
upsert_music as (
    insert into musics as m (artist_id, genre_id, folder_id, album_id, rating, duration, path, title, number, size, youtube, created_at)
    values (
        (select artist_id from upsert_artist limit 1),
        (select genre_id from upsert_genre limit 1),
        (select folder_id from upsert_folder limit 1),
        (select album_id from upsert_album limit 1),
        %(rating)s, %(duration)s, %(path)s, %(title)s, %(number)s, %(size)s, %(youtube)s, now())
    on conflict (path) do update set
        updated_at=coalesce(EXCLUDED.updated_at, now()),
        artist_id=EXCLUDED.artist_id,
        genre_id=EXCLUDED.genre_id,
        folder_id=EXCLUDED.folder_id,
        album_id=EXCLUDED.album_id,
        rating=EXCLUDED.rating,
        duration=EXCLUDED.duration,
        title=EXCLUDED.title,
        number=EXCLUDED.number,
        size=EXCLUDED.size,
        youtube=coalesce(EXCLUDED.youtube, m.youtube)
    returning m.id as music_id
)
insert into music_tags (music_id, tag_id)
select m.music_id, k.tag_id from upsert_music m, upsert_keywords k
on conflict (music_id, tag_id) do nothing;
delete from tags t where t.id in (select t.id from tags t left join music_tags mt on t.id = mt.tag_id group by t.id having count(mt.music_id) = 0);
'''
            import psycopg2
            with psycopg2.connect(db.connection_string) as conn:
                with conn.cursor() as cur:
                    for f in files:
                        m = File(f[1], f[0])
                        cur.execute(sql, m.to_dict())
                        bar.update(1)
                conn.commit()
        else:




with tqdm(total=size, file=sys.stdout, desc="Loading music", leave=True, position=0, disable=config.quiet) as bar:
    async def insert(semaphore, f):
        async with semaphore:
            try:
                m = File(f[1], f[0])
                if crawl:
                    await m.find_youtube()
                    bar.update(1)
                logger.debug(m.to_list())
                await db.upsert(m)
                bar.update(1)
            except asyncpg.exceptions.CheckViolationError as e:
                logger.warning("Violation: {}".format(e))
    semaphore = asyncio.BoundedSemaphore(concurrency)
    tasks = [asyncio.ensure_future(insert(semaphore, f)) for f in files]
    await asyncio.gather(*tasks)


def check_consistency(musics, checks, no_checks):
    report = []
    for m in musics:
        try:
            if 'keywords' in checks and 'keywords' not in no_checks:
                f = file.MusicFile(m.path)
                if m.path.endswith('.flac'):
                    if f.comment and not f.description:
                        report.append('Comment (' + f.comment +
                                      ') used in flac: ' + m.path)
                if m.path.endswith('.mp3'):
                    if f.description and not f.comment:
                        report.append(
                            'Description (' +
                            f.description +
                            ') used in mp3 : ' +
                            m.path)
            if 'title' in checks and 'title' not in no_checks and not m.title:
                report.append("No title  : '" + m.title + "' on " + m.path)
            if 'strict_title' in checks and 'strict_title' not in no_checks:
                filename = os.path.basename(m.path)
                if filename == "{} - {}.mp3".format(str(m.number).zfill(2), m.title):
                    continue
                if filename == "{} - {}.flac".format(str(m.number).zfill(2), m.title):
                    continue
                report.append("Invalid title format, '{}' should start by '{}'".
                              format(filename, '{} - {}'.format(str(m.number).zfill(2), m.title)))
            if 'path' in checks and 'path' not in no_checks and m.artist not in m.path:
                report.append("Artist invalid : " +
                              m.artist + " is not in " + m.path)
            if 'genre' in checks and 'genre' not in no_checks and m.genre == '':
                report.append("No genre : " + m.path)
            if 'album' in checks and 'album' not in no_checks and m.album == '':
                report.append("No album :i " + m.path)
            if 'artist' in checks and 'artist' not in no_checks and m.artist == '':
                report.append("No artist : " + m.path)
            if 'rating' in checks and 'rating' not in no_checks and m.rating == 0.0:
                report.append("No rating : " + m.path)
            if 'number' in checks and m.number == -1:
                report.append("Invalid track number : " + m.path)
        except OSError:
            report.append("Could not open file : " + m.path)
    return report
